= slide 'Днес' do
  list:
    Още метапрограмиране
    Още за обектния модел на Ruby

= slide 'Първи тест' do
  list:
    На 3 декември, вместо лекция; ще бъдете разделени на две групи
    30 затворени въпроса, 45 минути; верен отговор = 1 т.; грешен = 0 т.
    Ще включва материал, предаден до 1 декември, включително
    Има два теста, носят по максимум 30 точки всеки
    Вторият тест ще е в края на семестъра и/или по време на сесията

= slide 'Четвърта задача' do
  list:
    [Четвърта задача е на линия от днес сутринта](/tasks/4)
    Срокът е до идната сряда, 17:00
    Засяга една от силните страни в Ruby – `DSL`-и (domain specific languages)
    Ако не ви е ясно как да подходите, минете внимателно лекциите от понеделник и от днес

= slide 'Още две предизвикателства' do
  list:
    Планираме да ви дадем още едно или две предизвикателства идните дни
    Целта ще бъде упражнение на наученото за метапрограмиране
    Косвено – помощ за четвърта задача

= slide 'Въпрос 1' do
  p Как Ruby пази полета и методи?

  .answer.action
    ul
      li Полетата се пазят в обекти
      li Методите се пазят в модули
      li Обеките нямат методи (освен ако не са модули)

= slide 'Въпрос 2' do
  p Кажете ми всичко, което знаете за instance променливите.

  .answer.action
    ul
      li Пазят се в обект
      li Достъпни са в наследници
      li Не са директно достъпни извън обекта
      li Трябва да се ползват методи за достъп (напр. <code>attr_accessor</code>)
      li Могат да се достъпят "заобиколно" с <code>instance_variable_get</code> и компания

= slide 'Въпрос 3' do
  p Кой е класът на <code>"foo"</code>? На <code>Integer</code>? На <code>Class</code>?

  p Кой е родителят на <code>String</code>? На <code>Object</code>? На <code>Class</code>?

  .answer.action
    annotate:
      "foo".class == String  # =>
      Integer.class == Class # =>
      Class.class == Class   # =>

      String < Object        # =>
      Object < BasicObject   # =>
      Class < Module         # =>

= slide 'Въпрос 4' do
  p Какво прави <code>instance_eval</code>?

  p.answer.action Изпълнява блока с променен <code>self</code>.

= slide 'Въпрос 5' do
  p Как Ruby знае къде да постави метод, дефиниран с <code>def</code>?

  p.answer.action
    ' Винаги има текущ клас, в който този метод отива. Той може да се промени
      с <code>module</code>, <code>class</code> и <code>class_eval</code>. Всъщност,
      дори с <code>instance_eval</code>, но за това — по-късно.

= slide 'Въпрос 6' do
  p Можем ли да направим така, че вместо изключения, несъществуващи локални променливи или методи да резултират в <code>nil</code>? Как?

  example:
    foo          # => nil
    foo.bar.baz  # => nil

  .answer.action
    p Можем, като предефинираме метода <code>method_missing</code> в <code>BasicObject</code>.

    example:
      class BasicObject
        def method_missing(*) end
      end

= slide 'Въпрос 7' do
  p Ако имаме името на метод в променлива, например <code>method_name = 'first_name'</code>, можем ли динамично да създадем такъв метод? Как?

  example:
    class MyObject
      method_name    = 'first_name'
      implementation = -> { @data_store['first_name'] }

      # Dynamically define a first_name "getter"?
    end

  .answer.action
    p Бихме могли да използваме <code>define_method</code>:

    example:
      class MyObject
        method_name    = 'first_name'
        implementation = -> { @data_store['first_name'] }

        define_method(method_name, &implementation)
      end

= slide 'Въпрос 7 (продължение)', 'някои алтернативи' do
  example:
    method_name    = 'first_name'
    implementation = -> { @data_store['first_name'] }

    MyObject.send :define_method, method_name, &implementation

  .action
    p Или:

    example:
      some_class     = MyObject
      method_name    = 'first_name'
      implementation = -> { @data_store['first_name'] }

      some_class.class_eval do
        define_method(method_name, &implementation)
      end

= slide 'Най-важните неща от миналата лекция' do
  list:
    `method_missing`
    `instance_eval`/`class_eval`
    `define_method`
    Схемата на OO модела в Ruby

= slide 'instance_eval' do
  annotate:
    some_list = []

    some_list.instance_eval do
      push 5
      push 'foo'
      push :bar
      push [:another, :list]

      size # =>
    end

    some_list # =>

= slide 'def object.method' do
  p Може да (пре)дефинирате метод в конкретен обект.

  annotate:
    things = [22, :f, 'Sofia']

    def things.size
      -5
    end

    def things.asl
      "#{self[0]}/#{self[1]}/#{self[2]}"
    end

    things        # =>
    things.size   # =>
    things.length # =>
    things.asl    # =>

    [].asl        #!
    [].size       # =>

= slide 'Singleton класове' do
  list:
    Само модули могат да съдържат методи
    Когато дефинирате метод на конкретен обект, Ruby го добавя в специален клас за този обект
    Всеки обект има специален клас, наречен singleton class, който съдържа специалните за него методи
    Горното е полу-истина. Такъв клас се създава само ако има нужда
    Известен е още като metaclass, eigenclass и собствен клас

= slide 'Singleton класове', 'визуализация' do
  img src="13/metaclass.svg" style="width: 80%"

= slide 'Object#singleton_class' do
  p Собственият клас е достъпен чрез <code>#singleton_class</code>

  annotate:
    things = []

    def things.answer
      42
    end

    things.singleton_class # =>
    things.singleton_class.instance_methods(false) # =>

    [].singleton_class.instance_methods(false)     # =>

= slide 'Symbol и Integer', '...и техните метакласове' do
  p
    ' Целите числа и символите нямат собствени класове. Това е заради оптимизация.
      В Ruby интерпретатора, те се представят по много различен начин от всички други
      обекти.

  annotate:
    1_000.singleton_class #!
    :blah.singleton_class #!

= slide 'class << thing', 'алтернативен синтаксис' do
  p Можете да отворите собствения клас на обект с <code>class &lt;&lt;</code>

  annotate:
    things = [22, :f, 'Sofia']

    class << things
      def size
        -5
      end

      def asl
        "#{self[0]}/#{self[1]}/#{self[2]}"
      end
    end

    things.asl  # =>
    things.size # =>

= slide 'super и eigenclass' do
  p Оригиналният метод е достъпен чрез <code>super</code>.

= slide 'super и eigenclass (2)' do
  annotate:
    things = [22, :f, 'Sofia']

    class << things
      def each
        super
        yield :P
      end
    end

    aggregated = []
    for thing in things
      aggregated << thing
    end

    aggregated # =>

= slide 'super и eigenclass', 'OMG момент' do
  p Някой има ли идея защо <code>super</code> работи?

  .action
    annotate:
      things = []

      def things.answer
        42
      end

      things.singleton_class # =>
      things.singleton_class.superclass # =>

    p Да, eigenclass-ът е наследник на класа на обекта

= slide 'superclass и eigenclass', 'визуализация' do
  img src="13/metaclass-superclass.svg" style="width: 80%"

= slide 'Класови методи' do
  p Вероятно помните, че класови методи могат да се дефинират така:

  annotate:
    class Something
      def Something.foo() 42 end
      def self.bar() 42 end

      class << self
        def qux() 42 end
      end
    end

= slide 'Класови методи', '...всъщност' do
  p Класовите методи се пазят в собствения клас на класа

  annotate:
    class Something
      def self.answer() 42 end
    end

    Something.singleton_class # =>
    Something.singleton_class.instance_methods(false) # =>

= slide 'Класови методи', 'визуализация' do
  img src="13/class-metaclass.svg" style="width: 80%"

= slide 'extend', '...върху клас' do
  p Помните ли <code>extend</code>?

  annotate:
    module Knowledge
      def answer() 42 end
    end

    class Something
      extend Knowledge
    end

    Something.answer # =>

= slide 'extend', '...върху не-клас' do
  annotate:
    module Knowledge
      def answer() 42 end
    end

    text = "fourty-two"
    text.extend Knowledge

    text.answer # =>

  p.action Сещате ли се как може да се имплементира?

= slide 'extend', '...с class <<' do
  annotate:
    module Knowledge
      def answer() 42 end
    end

    class Something; end

    class << Something
      include Knowledge
    end

    Something.answer # =>

= slide 'extend', '...чрез instance_eval и eigenclass' do
  annotate:
    module Knowledge
      def answer() 42 end
    end

    class Something; end

    Something.singleton_class.instance_eval { include Knowledge }

    Something.answer # =>

= slide 'extend', '...чрез include' do
  annotate:
    module Knowledge
      def answer() 42 end
    end

    class Something; end

    Something.singleton_class.include Knowledge

    Something.answer # =>

  p Изводът е, че <code>include</code> и <code>extend</code> са просто методи, викащи се на определени обекти.

= slide 'Класови методи и наследяване' do
  p Класовите методи на родителя са достъпни в класовите методи на наследника:

  annotate:
    class Something
      def self.answer() 42 end
    end

    class Other < Something
      def self.better_answer() answer * 2 end
    end

    Other.better_answer # =>

= slide 'Класови методи и наследяване', 'друг OMG момент' do
  p Собственият клас на наследника наследява собствения клас на родителя:

  annotate:
    class Something; end
    class Other < Something; end

    Something.singleton_class        # =>
    Other.singleton_class.superclass # =>

    Something.singleton_class == Other.singleton_class.superclass # =>

= slide 'Класови методи и наследяване', 'визуализация' do
  img src="13/class-metaclass-superclass.svg" style="width: 80%"

= slide 'Класови методи и наследяване' do
  list:
    Това продължава още едно ниво нагоре – до `BasicObject` и неговия метаклас
    Метакласът на `BasicObject` наследява от `Class`
    Тук "цикълът" се затваря и нещата започват да изглеждат както при метакласове на обикновени обекти
    Обърнете внимание на разликата в родителя на метакласа при обикновени обекти и при обекти тип "клас"
    При класове (които също са обекти), йерархията е по-различна

= slide 'Класови методи и наследяване', 'takeaway' do
  blockquote
    ' Метакласът на суперкласа е суперкласът на метакласа.

= slide 'Grand Unified Theory' do
  ol
    li.action Има само един вид обекти - били те обикновени или модули
    li.action Има само един вид модули - били те обикновени или клас
    li.action Има само един вид методи - живеят в модули, които често са класове
    li.action Всеки обект има "реален клас" - бил той обикновен клас или собствен клас
    li.action Всеки клас има точно един суперклас - с изключение на <code>BasicObject</code>
    li.action Суперкласът на метакласа на обект е класът на обекта. Суперкласът на метакласа на клас е метакласът на родителя на класа.
    li.action При извикване на метод, Ruby взема "реалния клас" и търси в неговия ancestor chain

  p.action &#8718;

= slide 'Ancestor chains' do
  list:
    Викайки метод на <em>произволен</em> обект `object`, Ruby го търси в `object.singleton_class.ancestors`
    Тоест, за всеки инстанционен метод, в това число и "класовите", се гледа ancestor chain-а на singleton класа на обекта
    А класовите методи са просто инстанционни методи и инстанцията е обектът от тип "клас"
    Толкова просто е

= slide 'Няколко примера за ancestor chains' do
  p Относно търсенето на (инстанционни) методи на обектите от тип <code>String</code>:

  example:
    ''.singleton_class.ancestors
    # => [#<Class:#<String:0x007f8788e51bd8>>, String,
    #     Comparable, Object, Kernel, BasicObject]

    ''.class.ancestors
    # => [String, Comparable, Object, Kernel, BasicObject]

    String.ancestors
    # => [String, Comparable, Object, Kernel, BasicObject]

= slide 'Ancestor chains', 'за "класови" методи' do
  p По отношение на "класовите" методи, викани върхy <code>String</code>:

  example:
    String.singleton_class.ancestors
    # => [#<Class:String>, #<Class:Object>, #<Class:BasicObject>,
    #    Class, Module, Object, Kernel, BasicObject]

    String.class.ancestors
    # => [Class, Module, Object, Kernel, BasicObject]

    Class.ancestors
    # => [Class, Module, Object, Kernel, BasicObject]

= slide 'Пето предизвикателство' do
  list:
    Избягвайте помощни методи при monkey patching
    Ако слагате такива, поне ги направете private
    Може да ползвате и локална lambda/proc в кода на метода си
    Условието "enumerator ако няма блок": `some_collection.each(&block)`
    `String#split(//)` vs. `String#chars` – кое е по-ясно?

= slide 'Идната седмица...' do
  list:
    Лекция за Git - разберете архитектурата, за да разберете инструмента
    Лекция за Регулярни изрази
