= slide 'Днес' do
  list:
    Ще се забавляваме с регулярни изрази (очевидно)
    Регулярните изрази в бита на програмиста
    Регулярните изрази в Ruby (2.1.5)
    Как да ги ползваме в Ruby код
  div.action
    annotate:
      /find me/.match 'Can you find me here?' # =>
 
= slide 'Кой...?' do
  list:
    ...е карал/кара Езици, автомати, изчислимост?
    ...знае за `.`, `\w`, `\d`, `+`, `*`, `?` и още +/-3?
    ...е виждал пълната им фунционалност в друг език?
    ...може да прочете произволен регулярен израз?

= slide 'Stand back...' do
  a href="http://xkcd.com/208/"
    img src="14/regular_expressions.png"
    p style="text-align: center;"
      small
        em Wait, forgot to escape a space. Wheeeeee[taptaptap]eeeeee.

= slide 'Знам регулярни изрази!', 'За просветените в тайнството...' do
  list:
    Чували сте за регулярни изрази?
    Чувствате се умели в употребата им?
    Страхувате се, че ще ви е скучно днес?
    Ето ви дребни задачки, за да не ви е скучно

= slide 'Традиционната задача', 'за тези от вас, които се чувстват комфортно с РИ' do
  p Имаме следната задача:
  blockquote
    | Да се напише кратък Ruby expression, който проверява дали дадено число е просто или не,
      посредством употреба на регулярен израз. Резултатът от изпълнението му трябва да е <code>true</code>
      за прости числа и <code>false</code> за всички останали. Неща, които можете да ползвате:
    list:
      Самото число, разбира се.
      Произволни методи от класа `Regexp`
      Подходящ регулярен израз (шаблон)
      Текстовия низ `'1'`.
      `String#*`.
      Някакъв условен оператор (например `if`-`else` или `? … : …`)
      `true`, `false`, ...
  list:
    Материалът, необходим за решаването й, ще го има изцяло в днешната лекция.

= slide 'И още една задача', 'за тези от вас, които вече ни знаят номерата' do
  p Имаме следната задача:
  blockquote
    | Да валидирате изрази от следния тип за правилно отворени/затворени скоби:
    list:
      `(car (car (car ...)))`
      Например: `(car (car (car (car list))))`
      Целта е израз, чийто резултат да може да се ползва в условен оператор (`true`/`false`-еквивалент)
      Можете да ползвате произволни методи от класа `Regexp`
      И регулярен израз, разбира се
 
= slide 'И още', 'за тези от вас, които вече ни знаят номерата' do
  blockquote
    | Сменете * на % ако тя не е екранирана (escape-ната)
    list:
      `foo*`     => `foo%`
      `foo\*`    => `foo\*`
      `foo\\\\*` => `foo\\\\%`
      `*\\**`    => `%\\*%`
      Може и да стане без look-ahead/behind/... :)

= slide 'MOAR, MOAR!!!!111!', 'за тези от вас, които вече ни знаят номерата' do
  blockquote
    | Проверете дали нещо е валиден математически израз
    list:
      Произволно число цяло `1337`
      Променлива (латинска малка буква) `x`
      Операция между валидни изрази (+, -, *, /) `x + y - 21 / 3`
      Скоби, ограждащи валидни изрази `-x * (y + -5 * (7 - 13)) / 44 - 9000`
  list:
    Ще обсъдим възможните решения и задачите по-късно в рамките на днешната сбирка.
 
= slide 'Disclaimer' do
  blockquote
    em Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.

= slide '...summons tainted souls into the realm of the living...' do
  a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags"
    img src="14/xhtml_tags_regex.png"
    p style="text-align: center;"
      small
        em will liquify the n​erves of the sentient whilst you observe, your psyche withering in the onslaught of horror
 
= slide 'Произход', 'малко обща култура' do
  list:
    На възраст над 60 години (Клини, regular sets, ок. 1950 г.)
    Practical Extraction and Report Language
    Perl и PCRE-библиотеката (Perl-Compatible Regular Expressions)
    Почти всеки general-purpose програмен език имплементира някаква форма на РИ
    Незаменими unix-програми като `grep`, `sed`, `awk`, `vi`, `Emacs`...
    Разглеждат се в курса по Езици, автомати, изчислимост
 
= slide 'Проблемна област', 'най-общо: работа с текстови низове' do
  list:
    Търсене на по-сложна последователност от символи в низ
    Заместване на такива последователности с нещо друго
    Модифициране на текстови последователности (например, Markdown към HTML)
    Проверка дали даден низ отговаря на определени условия (валидация)
    Проверка дали едно число е просто или не :) Не.
 
= slide 'Понятия', 'и терминология' do
  list:
    „шаблон“, още „регулярен израз“ (pattern)
    Специални символи (meta characters)
    Екраниране на специалните символи (escape-ване)
    Повторители и повторение (quantifiers and repetition)
    Класове от символи (character classes)
    Групи
    Флагове (modifiers) на шаблона
 
= slide 'РИ в Ruby', 'синтаксис, накратко' do
  list:
    Всеки регулярен израз е обект, инстанция на класа `Regexp`
    Има литерален синтаксис за създаване на регулярни изрази: `/pattern/`
    Може да се ползва и синтаксисът с `%r`, например: `%r{/path/maching/made/easy}`
    Операциите с регулярни изрази са методи на `Regexp`
    Класът `String` също има методи за работа с регулярни изрази
 
= slide 'Regexp#match', 'ще го ползваме в примерите' do
  list:
    За да демонстрираме какво "хващат" определени шаблони, ще ползваме `Regexp#match`
    Този метод примема аргумент текстов низ и връща `nil`, ако шаблонът не "хваща" нищо
    Връща инстанция на `MatchData`, ако шаблонът "хваща" нещо от низа
    `MatchData` в детайли — по-късно
    От тук нататък ще ползваме <em>match-ва</em> като синоним на <em>"хваща"</em> :)
 
= slide 'Шаблони', '(регулярни изрази, patterns и т.н.)' do
  list:
    В сърцето на всеки регулярен израз стои шаблон (pattern)
    В шаблона, всеки символ (освен някои специални) означава себе си
    Следователно, шаблонът `/wool/` ще отговаря на точно тази последователност от символи в низ
    Цялата магия е в специалните символи:
    `(`, `)`, `[`, `]`, `{`, `}`, `.`, `?`, `+`, `*`, `^`, `$`, `\`, ...
    Някои символи са специални само в определен контекст (например символът `-`)
 
= slide 'Най-прост пример' do
  annotate:
    /find me/.match 'Can you find me here?' # =>
    /find me/.match 'You will not find ME!' # =>
  list:
    Този шаблон не съдържа специални символи
    Както виждате, по подразбиране шаблоните са чувствителни към регистъра на буквите
    Последното може да се контролира с помощта на флагове към шаблона
 
= slide 'Специални символи', 'meta characters' do
  list:
    `.` съвпада с един произволен символ (с изключение на символите за нов ред)
    `[` и `]` се ползват за дефиниране на класове от символи
    `*`, `?`, `+`, `{` и `}` се ползват за указване на повторения
    `^`, `$`, `\b`, `\B` и т.н. са "котви" и съответстват на определени "междусимволни дупки" :)
    `|` има смисъл на "или", например:
  div.action
    annotate:
      /day|nice/.match  'A nice dance-day.'  # =>
      /da(y|n)ce/.match 'A nice dance-day.'  # =>
 
  p.action Внимавайте с приоритета на <code>|</code>
 
= slide 'Екраниране', 'на специалните символи (escape-ване)' do
  list:
    `\` пред специален символ го прави неспециален такъв (екранира го)
    За да вкарате наклонена черта, ползвате `\\` (като в обикновен низ)
 
= slide 'Класове от символи', '(character classes)' do
  list:
    Заградени между `[` и `]`
    Наподобяват множества
    Match-ват един символ от посочените вътре
    Могат да се декларират диапазони, например `[a-z]` или `[0-9A-F]`
    Можете да екранирате тире в символен клас така: `[a\-b]`
    Друг вариант е да сложите тирето в началото или в края на класа: `[-abc]` или `[abc-]` - тук то няма специален смисъл
    Ако първият символ в класа е `^`, това означава "някой символ, който не е посочен в класа"
    Има предефинирани класове от символи
 
= slide 'Примери с класове от символи' do
  annotate:
    /W[aeiou]rd/.match "Word" # =>
    /[0-9a-f]/.match '9f'     # =>
    /[9f]/.match     '9f'     # =>
    /[^a-z]/.match   '9f'     # =>
 
= slide 'Предефинирани класове от символи' do
  list:
    `\w` - символ от дума (`[a-zA-Z0-9_]`)
    `\W` - символ, който не може да участва в дума (`[^a-zA-Z0-9_]`)
    `\d` - цифра ([0-9])
    `\D` - символ, който не е цифра (`[^0-9]`)
    `\h` - шеснадесетична цифра (`[0-9a-fA-F]`)
    `\H` - символ, който не е шеснадесетична цифра (`[^0-9a-fA-F]`)
    `\s` - whitespace-символ (`/[ \t\r\n\f]/`)
    `\S` - символ, който не е whitespace (`/[^ \t\r\n\f]/`)
 
= slide 'POSIX-класове от символи' do
  list:
    `[[:alpha:]]` - символ от азбука
    `[[:alnum:]]` - горното или цифра
    `[[:blank:]]` - интервал или таб
    `[[:cntrl:]]` - контролен символ
    `[[:digit:]]` - цифра
    `[[:lower:]]` - малка буква
    `[[:upper:]]` - главна буква
    `[[:print:]]` - printable-символ
    `[[:punct:]]` - пунктуационен символ
    `[[:space:]]` - whitespace-символ (вкл. и нов ред)
    `[[:xdigit:]]` - шеснадеситична цифра
    И други...
 
= slide 'Полезни не-POSIX класове' do
  list:
    Ruby поддържа и следните не-POSIX символни класове:
    `[[:word:]]` - символ, който може да участва в дума (работи и за Unicode, за разлика от `\w`)
    `[[:ascii:]]` - ASCII-символ
 
= slide 'Символни свойства', 'character properties' do
  list:
    С конструкцията `\p{}` може да match-вате символи, имащи определено свойство (подобно на POSIX)
    Например: `\p{Alnum}`, `\p{Alpha}`, `\p{Blank}`, `\p{Cntrl}`, `\p{Digit}`, `\p{Graph}`
    По този начин, например, може да проверите дали даден символ е от японската азбука катакана: `\p{Katakana}`
    Или пък да match-нете символ от азбука на кирилица: `\p{Cyrillic}`, например:
 
  div.action
    annotate:
      /\s\p{Cyrillic}\p{Cyrillic}\p{Cyrillic}/.match 'Ние сме на всеки километър!' # #<MatchData " сме">
 
= slide 'Котви' do
  list:
    Не съвпадат с реални символи, а вместо това с невидимите граници между тях
    `^` съвпада с началото на ред (Ruby е в multiline режим по подразбиране)
    `$` съвпада с края на ред
    `\A` съвпада с началото на текстов низ
    `\z` съвпада с края на низ
    `\b` отговаря на граница на дума (когато е извън `[` и `]`; вътре означава `backspace`)
    `\B` отговаря на място, което не е граница на дума
 
= slide 'Примери с котви' do
  annotate:
    /real/.match "surrealist"    # =>
    /\Areal/.match "surrealist"  # =>
    /\band/.match "Demand"       # =>
 
    /\Band.+/.match "Supply and demand curve" # =>
 
= slide 'Повторители', '(quantifiers)' do
  list:
    Важат за непосредствено предхождащия ги символ/клас/група; нека го означим със `s`
    `s*` означава нула или повече повторения на `s`
    `s+` търси едно или повече повторения на `s`
    `s?` съвпада с нула или едно повторение на `s`
    `s{m,n}` означава между m и n повторения на `s`
    В последното можем да пропуснем `m` или `n`:
    `s{,n}` има смисъл на нула до `n` повторения, а `s{m,}` — поне `m` повторения
    `s{n}` означава точно `n` повторения
 
= slide 'Примери с повторители' do
  annotate:
    /e+/.match     'Keeewl'       # =>
    /[Kke]+/.match 'Keeewl'       # =>
    /\w+/.match '2038 - the year' # =>
    /".*"/.match '"Quoted text!"' # =>
 
    /[[:upper:]]+[[:lower:]]+l{2}o/.match 'Hello' # =>
 
= slide 'Алчност', 'и лакомия...' do
  list:
    По подразбиране повторителите са "алчни", т.е. изяждат колкото се може повече от низа
    Това поведение може да се контролира с `?` след повторителя
    Например `.*?` кара повторителя `*` да се държи не-лакомо
    Внимавайте с лакомите повторители
  div.action
    annotate:
      /<.+>/.match("<a><b>")  # =>
      /<.+?>/.match("<a><b>") # =>
 
= slide 'Групи', 'и прихващане' do
  p Символите <code>(</code> и <code>)</code> се използват за логическо групиране на части от шаблона с цел:
  list:
    Контролиране областта на влияние на дадена операция
    Например, следното ще match-ва низове, съдържащи думите `day` или `dance`: `/\bda(y|nce)\b/`
    Възможност за референция към „ограденото“ в скобите — в и извън шаблона
    Задаване на по-специални (и не толкова често употребявани) конструкции
    Групите биват номерирани или именовани
 
= slide 'Референции към групи' do
  p Текстът, който match-ва частта на шаблона, оградена в скоби, може да се достъпва:
  list:
    В самия шаблон, с нотацията `\1` за първата група, `\2` за втората и т.н.
    Отвън, през `MatchData`-обекта
    Отвън, през специални променливи от типа на `$1`, `$2`... за номерирани групи
    Отвън, през локални променливи, за именовани групи
 
= slide 'Референции към групи', 'извън шаблона, за номерирани групи, през MatchData' do
  example:
    date_string = '2012-11-12'
    date_parts  = /\A(\d{4})-(\d\d)-(\d\d)\z/.match(date_string)
 
    if date_parts
      Date.new date_parts[1].to_i, date_parts[2].to_i, date_parts[3].to_i
      # #<Date: 2012-11-12 ...>
    end
 
= slide 'Пропускане на уловени групи' do
  list:
    Понякога ни се налага да използваме групи за примерно "или" `(foo|bar)`, но не искаме тази група да се намесва в `$1`, `$2`, ...
    Това правим чрез `(?:foo|bar)`
  div.action
    annotate:
      /(\d+)(st|nd|rd|th)? (\w+)/.match '1st June' # =>
      /(\d+)(?:st|nd|rd|th)? (\w+)/.match '1st June' # =>
      /(\d+)(st|nd|rd|th)? (\w+)/.match '1 June' # =>
      /(\d+)(?:st|nd|rd|th)? (\w+)/.match '1 June' # =>
 
= slide 'if с регулярни изрази' do
  list:
    `=~` и `!~` — дефинирани в `Regexp` и в `String`
    Можем да правим така: `/pattern/ =~ 'Some string'`
    Както и така: `'Some string' =~ /pattern/`
    Връща `nil`, ако няма съвпадение, или число (offset), ако има такова
    След изпълнение на този оператор също имаме попълнени специални променливи (`$1`, `$~`...)
    Удобно е да се ползва в условни конструкции, например `if`
 
= slide 'if с регулярни изрази', 'пример' do
  annotate:
    log_entry = "[2011-07-22 15:42:12] - GET / HTTP/1.1 200 OK"
 
    if log_entry =~ /\bHTTP\/1\.1 (\d+)/
      request_status = $1.to_i # =>
    else
      raise "Malformed log entry!"
    end
 
= slide 'Референции към групи', 'извън шаблона, за номерирани групи, през $1, $2...' do
  example:
    date_string = '2012-11-12'
 
    if date_string =~ /\A(\d{4})-(\d\d)-(\d\d)\z/
      Date.new $1.to_i, $2.to_i, $3.to_i # #<Date: 2012-11-12 ...>
    end
 
= slide 'Именовани групи' do
  list:
    Като обикновена група, само че се обръщате към тях не с цифра, а с име
    Дефинират се така: `(?&lt;name&gt;)` или така: `(?'name')`, където `name` е името на групата
    Например: `(?&lt;date&gt;\d{4}-\d{2}-\d{2})`
  div.action
    annotate:
      /(?<date>\d{4}-\d{2}-\d{2})/.match 'Today is 2011-11-08, Tuesday.' # =>
 
= slide 'Референции към групи', 'в рамките на шаблона' do
  list:
    `\1`, `\2` и прочее, ако групите ви не са именовани
    Ако имате повече от 9 групи, можете да ги реферирате по същия начин:
    `\11` се обръща към 11-тата група
    Ами ако искам да кажа: "текстът, отговарящ на група `\1`, последван от символа `1`"?
    Ползвате следния общ синтаксис: `\k&lt;group_identifier&gt;`, където `group_identifier` е число или име на група
    Този общ синтаксис се използва и за обръщение към текста, отговарящ на именовани групи:
    `/(?&lt;word&gt;\w+), \k&lt;word&gt;/`
 
= slide 'Примери за референции към групи' do
  example:
    /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/.match 'Today is 2011-11-08, Tuesday.'
    # #<MatchData "2011-11-08" year:"2011" month:"11" day:"08">
 
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\11/.match 'Regular expressions'
    # #<MatchData "ular express" 1:"u" 2:"l" 3:"a" 4:"r" 5:" " 6:"e" 7:"x" 8:"p" 9:"r" 10:"e" 11:"s">
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\k<11>1/.match 'Regular express1ions'
    # #<MatchData "ular express1" 1:"u" 2:"l" 3:"a" 4:"r" 5:" " 6:"e" 7:"x" 8:"p" 9:"r" 10:"e" 11:"s">
 
  list:
    Забележете, че в рамките на един шаблон <strong>не може</strong> да ползвате и двата вида рефериране към групи
 
= slide 'Уточнение относно референциите', 'в рамките на шаблона' do
  list:
    Обърнете внимание, че референцията е към порцията текст, match-нат от групата, а не към самата група!
    Например:
  div.action
    annotate:
      /(\w+), \1/.match 'testing, testing' # =>
      /(\w+), \1/.match 'testing, twice'   # =>
 
      /(?<word>\w+), \k<word>/.match 'testing, testing' # =>
 
= slide 'Backtracking' do
  list:
    Често срещан термин в регулярните изрази, свързан с имплементацията им
    Често се случва, когато имате "алчни" повторители
    Ето пример как работи:
 
  .action
    annotate:
      /".*"/.match '"Quoted"' # =>
 
    p Частта от шаблона <code>.*</code> хваща <code>Quoted"</code>, тъй като е алчна. Това води до невъзможност да се намери съвпадение и алгоритъмът backtrack-ва -- връща се една стъпка/символ назад.
 
= slide 'Атомарни (неделими) групи' do
  list:
    Атомарните (неделими) групи могат да променят това поведение
    Атомарна група се дефинира така: `(?>pattern)`
    Според документацията, се ползват за оптимизация и предотвратяване на излишно backtrack-ване
    Например:
 
  .action
    annotate:
      /"(?>.*)"/.match('"Quote"') # =>
 
= slide 'Рекурсивни групи' do
  list:
    Ако вместо порцията текст, отговаряща на дадена група, искате да преизпълните групата?
    Ползвате следния синтаксис: `\g&lt;name&gt;`, където `name` е номер или име на група в шаблона
    Това <strong>преизпълнява</strong> шаблона, не търси за вече намерения текст
    Има смисъл за да направи шаблоните ви една идея по-DRY
    Например:
  div.action
    annotate:
      /(\w+), \1/.match    'testing, twice'   # =>
      /(\w+), \g<1>/.match 'testing, twice'   # =>
 
= slide 'Рекурсивни групи', 'втора част' do
  list:
    С помощта на горното можете да дефинирате рекурсивни групи
    Спомняте ли си втория проблем, който поставихме в началото?
  blockquote.action
    | Да валидирате изрази от следния тип за правилно отворени/затворени скоби:
    list:
      `(car (car (car ...)))`
      Например: `(car (car (car (car list))))`
      Целта е израз, чийто резултат да може да се ползва в условен оператор (`true`/`false`-еквивалент)
      Можете да ползвате произволни методи от класа `Regexp`
      И регулярен израз, разбира се
 
= slide 'Примерно решение', 'с рекурсивни групи' do
  annotate:
    validator = /^(\(car (\g<1>*|\w*)\))$/
 
    valid   = '(car (car (car (car list))))'
    invalid = '(car (car (car list))'
 
    validator.match(valid)   ? true : false # =>
    validator.match(invalid) ? true : false # =>
